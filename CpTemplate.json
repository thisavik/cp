{
	"basic snippet": {
		"prefix": "code",
		"body": [
			"/*",
			" *  author: thisavik",
			" *  created: $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_DAY_NAME_SHORT",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define rep(i, n) for(int i = 0; i < n; i++)",
			"#define range(i, a, b) for (int i = a; i <= b; i++)",
			"#define rrep(i, a, b) for (int i = a; i >= b; i--)",
			"#define all(x) (x).begin(), (x).end()",
			"",
			"void tool()",
			"{",
			"  ios_base::sync_with_stdio(false);",
			"  cin.tie(NULL);",
			"#ifndef ONLINE_JUDGE",
			"  freopen(\"C:\\Users\\Lenovo\\OneDrive\\Documents\\cp\\input.txt\", \"r\", stdin);",
			"  freopen(\"C:\\Users\\Lenovo\\OneDrive\\Documents\\cp\\output.txt\", \"w\", stdout);",
			"#endif",
			"}",
			"",
			"void solve()",
			"{",
			"",
			"}",
			"",
			"int32_t main(int32_t argc, char *args[])",
			"{",
			"  tool();",
			"  int t;",
			"  cin >> t;",
			"  while(t--)",
			"    solve(); ",
			"  return 0;",
			"}"
		],
		"description": "basic snippet"
	},
	"debug snippet": {
		"prefix": "debug",
		"body": [
			"#define rep(i, n) for (int i = 0; i < n; i++)",
			"#define range(i, a, b) for (int i = a; i <= b; i++)",
			"template <typename A, typename B>",
			"ostream &operator<<(ostream &out, const pair<A, B> &a)",
			"{",
			"  out << \"(\" << a.first << \",\" << a.second << \")\";",
			"  return out;",
			"}",
			"template <typename T, size_t N>",
			"ostream &operator<<(ostream &out, const array<T, N> &a)",
			"{",
			"  out << \"[\";",
			"  bool first = true;",
			"  for (auto &v : a)",
			"  {",
			"    out << (first ? \"\" : \", \");",
			"    out << v;",
			"    first = 0;",
			"  }",
			"  out << \"]\";",
			"  return out;",
			"}",
			"template <typename T>",
			"ostream &operator<<(ostream &out, const vector<T> &a)",
			"{",
			"  out << \"[\";",
			"  bool first = true;",
			"  for (auto &v : a)",
			"  {",
			"    out << (first ? \"\" : \", \");",
			"    out << v;",
			"    first = 0;",
			"  }",
			"  out << \"]\";",
			"  return out;",
			"}",
			"template <typename T, class Cmp>",
			"ostream &operator<<(ostream &out, const set<T, Cmp> &a)",
			"{",
			"  out << \"{\";",
			"  bool first = true;",
			"  for (auto &v : a)",
			"  {",
			"    out << (first ? \"\" : \", \");",
			"    out << v;",
			"    first = 0;",
			"  }",
			"  out << \"}\";",
			"  return out;",
			"}",
			"template <typename U, typename T, class Cmp>",
			"ostream &operator<<(ostream &out, const map<U, T, Cmp> &a)",
			"{",
			"  out << \"{\";",
			"  bool first = true;",
			"  for (auto &p : a)",
			"  {",
			"    out << (first ? \"\" : \", \");",
			"    out << p.first << \":\" << p.second;",
			"    first = 0;",
			"  }",
			"  out << \"}\";",
			"  return out;",
			"}",
			"#ifndef LOCAL",
			"#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)",
			"#else",
			"#define trace(...) 42",
			"#endif",
			"template <typename Arg1>",
			"void __f(const char *name, Arg1 &&arg1)",
			"{",
			"  cerr << name << \": \" << arg1 << endl;",
			"}",
			"template <typename Arg1, typename... Args>",
			"void __f(const char *names, Arg1 &&arg1, Args &&...args)",
			"{",
			"  const char *comma = strchr(names + 1, ',');",
			"  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";",
			"  __f(comma + 1, args...);",
			"}"
		],
		"description": "debug snippet"
	},
	"tool snippet": {
		"prefix": "tool",
		"body": [
			"",
      "void tool()",
      "{",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(NULL);",
      "#ifndef ONLINE_JUDGE",
      "  freopen(\"C:\\Users\\Lenovo\\OneDrive\\Documents\\cp\\input.txt\", \"r\", stdin);",
      "  freopen(\"C:\\Users\\Lenovo\\OneDrive\\Documents\\cp\\output.txt\", \"w\", stdout);",
      "#endif",
      "}",
      ""
		],
		"description": "for taking input from file & showing output in file"
	},
	"generic segment tree": {
		"prefix": "segtree",
		"body": [
			"struct segTree",
			"{",
			"  vector<int> seg;",
			"  vector<int> lazy;",
			"  int (*func)(int, int);",
			"  int constReturn;",
			"  segTree(int n, int constReturn, int (*func)(int, int))",
			"  {",
			"    this->constReturn = constReturn;",
			"    this->func = func;",
			"    seg.resize(4 * n + 1, 0);",
			"    lazy.resize(4 * n + 1, 0);",
			"  }",
			"  int build(vector<int> &arr, int s, int e, int idx = 0)",
			"  {",
			"    if (s > e)",
			"      return constReturn;",
			"    if (s == e)",
			"      return seg[idx] = arr[s];",
			"    int mid = (s + e) / 2;",
			"    return seg[idx] = func(build(arr, s, mid, 2 * idx + 1), build(arr, mid + 1, e, 2 * idx + 2));",
			"  }",
			"  int query(int s, int e, int &qs, int &qe, int idx = 0)",
			"  {",
			"    if (s > e || qs > e || qe < s)",
			"      return constReturn;",
			"    if (s >= qs && e <= qe)",
			"      return seg[idx];",
			"    int mid = (s + e) / 2;",
			"    return func(query(s, mid, qs, qe, 2 * idx + 1), query(mid + 1, e, qs, qe, 2 * idx + 2));",
			"  }",
			"  int update(int s, int e, int &i, int &val, int idx = 0)",
			"  {",
			"    if (s > e)",
			"      return constReturn;",
			"    if(i < s || i > e)",
			"      return seg[idx];",
			"    if (s == e)",
			"      return seg[idx] = val;",
			"    int mid = (s + e) / 2;",
			"    return seg[idx] = func(update(s, mid, i, val, 2 * idx + 1), update(mid + 1, e, i, val, 2 * idx + 2));",
			"  }",
			"  int updateRange(int s, int e, int val, int qs, int qe, int idx = 0)",
			"  {",
			"    if (s > e)",
			"      return constReturn;",
			"    if(s > qe || e < qe)",
			"      return seg[idx];",
			"    if (lazy[idx] != 0 && s != e)",
			"    {",
			"      lazy[2 * idx + 1] += lazy[idx];",
			"      lazy[2 * idx + 2] += lazy[idx];",
			"      lazy[idx] = 0;",
			"    }",
			"    if (s >= qs && e <= qe)",
			"    {",
			"      seg[idx] += val;",
			"      if (s != e)",
			"      {",
			"        lazy[2 * idx + 1] += val;",
			"        lazy[2 * idx + 2] += val;",
			"      }",
			"    }",
			"    int mid = (s + e) / 2;",
			"    return seg[idx] = func(updateRange(s, mid, val, qs, qe, 2 * idx + 1), updateRange(mid+1, e, val, qs, qe, 2 * idx + 2));",
			"  }",
			"};"
		],
		"description": "generic segment tree"
	},
	"sparse table for range query in O(1) & preprocessing in O(nlogn)": {
		"prefix": "sparse",
		"body": [
			"struct sparseTable",
			"{",
			"  vector<vector<int>> lookUp;",
			"  int (*func)(int, int);",
			"  sparseTable(vector<int> &a, int (*func)(int, int))",
			"  {",
			"    this->func = func;",
			"    build(a);",
			"  }",
			"  void build(vector<int> &a)",
			"  {",
			"    int n = a.size();",
			"    lookUp.resize(n, vector<int>((ceil)(log2(n)), 0));",
			"    // calculate for 2^0 length subarray",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"      lookUp[i][0] = a[i];",
			"    }",
			"    // calculate for each 2^j length subarray",
			"    for (int j = 1; (1 << j) <= n; j++)",
			"    {",
			"      for (int i = 0; i + (1 << j) <= n; i++)",
			"      {",
			"        // at index i if we want to calculate for 2^j length",
			"        // then func( i for 2^(j-1) len, i + 2^(j-1) for 2^(j-1) len ) will give its answer",
			"        lookUp[i][j] = func(lookUp[i][j - 1], lookUp[i + (1 << (j - 1))][j - 1]);",
			"      }",
			"    }",
			"  }",
			"  int query(int &l, int &r)",
			"  {",
			"    int i = log2(r - l + 1);",
			"    // to calculate for l, r",
			"    // we need to calculate func( l for 2^(i) len, r-2^i for 2^i len )",
			"    return func(lookUp[l][i], lookUp[r - (1 << i)][i]);",
			"  }",
			"};"
		],
		"description": "sparse table for range query in O(1) & preprocessing in O(nlogn)"
	}
}
