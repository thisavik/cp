{
	"pbds": {
		"prefix": "pdbs",
		"body": [
			"/*",
			" *  author: thisavik",
			" *  created: $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_DAY_NAME_SHORT",
			"**/",
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"#ifdef LOCAL",
			"#include \"algo/debug.h\"",
			"#else",
			"#define trace(...) 42",
			"#endif",
			"",
			"template <typename T, class cmp = std::less<T>>",
			"using ordered_set = tree<T, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"template <class key, class value, class cmp = std::less<key>>",
			"using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
			"// find_by_order(k)  returns iterator to kth element starting from 0;",
			"// order_of_key(k) returns count of elements strictly smaller than k;",
			"",
			"#define int long long",
			"#define rep(i, a, b) for (int i = a; i < b; i++)",
			"#define per(i, a, b) for (int i = a; i >= b; i--)",
			"#define all(x) (x).begin(), (x).end()",
			"",
			"void solve(int &tt)",
			"{",
			"}",
			"",
			"int32_t main(int32_t argc, char *args[])",
			"{",
			"  int tt;",
			"  cin >> tt;",
			"  while (tt--)",
			"    solve(tt);",
			"  return 0;",
			"}"
		],
		"description": "pbds"
	},
	"basic code": {
		"prefix": "code",
		"body": [
			"/*",
			" *  author: thisavik",
			" *  created: $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_DAY_NAME_SHORT",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#ifdef LOCAL",
			"#include \"algo/debug.h\"",
			"#else",
			"#define trace(...) 42",
			"#endif",
			"",
			"#define int int64_t",
			"#define rep(i, a, b) for (int i = a; i < b; i++)",
			"#define per(i, a, b) for (int i = a; i >= b; i--)",
			"#define all(x) (x).begin(), (x).end()",
			"",
			"void solve(int &tt)",
			"{",
			"  ",
			"}",
			"",
			"int32_t main(int32_t argc, char *args[])",
			"{",
			"  int tt;",
			"  cin >> tt;",
			"  for(int i = 1; i <= tt; i++)",
			"    solve(i);",
			"  return 0;",
			"}"
		],
		"description": "basic code"
	},
	"debug snippet": {
		"prefix": "debug",
		"body": [
			"namespace",
			"{",
			"    template <typename A, typename B>",
			"    ostream &operator<<(ostream &out, const pair<A, B> &a)",
			"    {",
			"        out << \"(\" << a.first << \",\" << a.second << \")\";",
			"        return out;",
			"    }",
			"    template <typename T, size_t N>",
			"    ostream &operator<<(ostream &out, const array<T, N> &a)",
			"    {",
			"        out << \"[\";",
			"        bool first = true;",
			"        for (auto &v : a)",
			"        {",
			"            out << (first ? \"\" : \", \");",
			"            out << v;",
			"            first = 0;",
			"        }",
			"        out << \"]\";",
			"        return out;",
			"    }",
			"    template <typename T>",
			"    ostream &operator<<(ostream &out, const vector<T> &a)",
			"    {",
			"        out << \"[\";",
			"        bool first = true;",
			"        for (auto &v : a)",
			"        {",
			"            out << (first ? \"\" : \", \");",
			"            out << v;",
			"            first = 0;",
			"        }",
			"        out << \"]\";",
			"        return out;",
			"    }",
			"    template <typename T, class Cmp>",
			"    ostream &operator<<(ostream &out, const set<T, Cmp> &a)",
			"    {",
			"        out << \"{\";",
			"        bool first = true;",
			"        for (auto &v : a)",
			"        {",
			"            out << (first ? \"\" : \", \");",
			"            out << v;",
			"            first = 0;",
			"        }",
			"        out << \"}\";",
			"        return out;",
			"    }",
			"    template <typename U, typename T, class Cmp>",
			"    ostream &operator<<(ostream &out, const map<U, T, Cmp> &a)",
			"    {",
			"        out << \"{\";",
			"        bool first = true;",
			"        for (auto &p : a)",
			"        {",
			"            out << (first ? \"\" : \", \");",
			"            out << p.first << \":\" << p.second;",
			"            first = 0;",
			"        }",
			"        out << \"}\";",
			"        return out;",
			"    }",
			"    #ifndef LOCAL",
			"    #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)",
			"    #else",
			"    #define trace(...) 42",
			"    #endif",
			"    template <typename Arg1>",
			"    void __f(const char *name, Arg1 &&arg1)",
			"    {",
			"        cerr << name << \": \" << arg1 << endl;",
			"    }",
			"    template <typename Arg1, typename... Args>",
			"    void __f(const char *names, Arg1 &&arg1, Args &&...args)",
			"    {",
			"        const char *comma = strchr(names + 1, ',');",
			"        cerr.write(names, comma - names) << \": \" << arg1 << \" |\";",
			"        __f(comma + 1, args...);",
			"    }  ",
			"}"
		],
		"description": "debug snippet"
	},
	"i/o using file": {
		"prefix": "tool",
		"body": [
			"void tool()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"C:/Users/thisa/OneDrive/Documents/cp/input.txt\", \"r\", stdin);",
			"    freopen(\"C:/Users/thisa/OneDrive/Documents/cp/output.txt\", \"w\", stdout);",
			"    freopen(\"C:/Users/thisa/OneDrive/Documents/cp/error.txt\", \"w\", stderr);",
			"#endif",
			"}"
		],
		"description": "i/o using file"
	},
	"segment tree for fast range query execution": {
		"prefix": "segment",
		"body": [
			"struct segmentTree",
			"{",
			"    vector<int> seg;",
			"    vector<int> lazy;",
			"    int (*func)(int, int);",
			"    int constReturn;",
			"    segTree(int n, int constReturn, int (*func)(int, int))",
			"    {",
			"        this->constReturn = constReturn;",
			"        this->func = func;",
			"        seg.resize(4 * n + 1, 0);",
			"        lazy.resize(4 * n + 1, 0);",
			"    }",
			"    int build(vector<int> &arr, int s, int e, int idx = 0)",
			"    {",
			"        if (s > e)",
			"            return constReturn;",
			"        if (s == e)",
			"            return seg[idx] = arr[s];",
			"        int mid = (s + e) / 2;",
			"        return seg[idx] = func(build(arr, s, mid, 2 * idx + 1), build(arr, mid + 1, e, 2 * idx + 2));",
			"    }",
			"    int query(int s, int e, int &qs, int &qe, int idx = 0)",
			"    {",
			"        if (s > e || qs > e || qe < s)",
			"            return constReturn;",
			"        if (s >= qs && e <= qe)",
			"            return seg[idx];",
			"        int mid = (s + e) / 2;",
			"        return func(query(s, mid, qs, qe, 2 * idx + 1), query(mid + 1, e, qs, qe, 2 * idx + 2));",
			"    }",
			"    int update(int s, int e, int &i, int &val, int idx = 0)",
			"    {",
			"        if (s > e)",
			"            return constReturn;",
			"        if (i < s || i > e)",
			"            return seg[idx];",
			"        if (s == e)",
			"            return seg[idx] = val;",
			"        int mid = (s + e) / 2;",
			"        return seg[idx] = func(update(s, mid, i, val, 2 * idx + 1), update(mid + 1, e, i, val, 2 * idx + 2));",
			"    }",
			"    int updateRange(int s, int e, int val, int qs, int qe, int idx = 0)",
			"    {",
			"        if (s > e)",
			"            return constReturn;",
			"        if (s > qe || e < qe)",
			"            return seg[idx];",
			"        if (lazy[idx] != 0 && s != e)",
			"        {",
			"            lazy[2 * idx + 1] += lazy[idx];",
			"            lazy[2 * idx + 2] += lazy[idx];",
			"            lazy[idx] = 0;",
			"        }",
			"        if (s >= qs && e <= qe)",
			"        {",
			"            seg[idx] += val;",
			"            if (s != e)",
			"            {",
			"                lazy[2 * idx + 1] += val;",
			"                lazy[2 * idx + 2] += val;",
			"            }",
			"        }",
			"        int mid = (s + e) / 2;",
			"        return seg[idx] = func(updateRange(s, mid, val, qs, qe, 2 * idx + 1), updateRange(mid + 1, e, val, qs, qe, 2 * idx + 2));",
			"    }",
			"};"
		],
		"description": "segment tree for fast range query execution"
	},
	"sparse table": {
		"prefix": "sparse",
		"body": [
			"struct sparseTable",
			"{",
			"    vector<vector<int>> lookUp;",
			"    int (*func)(int, int);",
			"    sparseTable(vector<int> &a, int (*func)(int, int))",
			"    {",
			"        this->func = func;",
			"        build(a);",
			"    }",
			"    void build(vector<int> &a)",
			"    {",
			"        int n = a.size();",
			"        lookUp.resize(n, vector<int>((ceil)(log2(n)), 0));",
			"        // calculate for 2^0 length subarray",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            lookUp[i][0] = a[i];",
			"        }",
			"        // calculate for each 2^j length subarray",
			"        for (int j = 1; (1 << j) <= n; j++)",
			"        {",
			"            for (int i = 0; i + (1 << j) <= n; i++)",
			"            {",
			"                // at index i if we want to calculate for 2^j length",
			"                // then func( i for 2^(j-1) len, i + 2^(j-1) for 2^(j-1) len ) will give its answer",
			"                lookUp[i][j] = func(lookUp[i][j - 1], lookUp[i + (1 << (j - 1))][j - 1]);",
			"            }",
			"        }",
			"    }",
			"    int query(int &l, int &r)",
			"    {",
			"        int i = log2(r - l + 1);",
			"        // to calculate for l, r",
			"        // we need to calculate func( l for 2^(i) len, r-2^i for 2^i len )",
			"        return func(lookUp[l][i], lookUp[r - (1 << i)][i]);",
			"    }",
			"};"
		],
		"description": "sparse table"
	},
	"binary index tree for fast range query execution": {
		"prefix": "fenwick",
		"body": [
			"struct BIT",
			"{",
			"    vector<int> bit;",
			"    int n;",
			"    BIT(int n) : n(n + 1)",
			"    {",
			"        bit.resize(this->n, 0);",
			"    }",
			"",
			"    void update(int idx, int val)",
			"    {",
			"        for (int i = idx; i <= n; i += (i & (-i)))",
			"            bit[i] += val;",
			"    }",
			"",
			"    int sum(int idx)",
			"    {",
			"        int ans = 0;",
			"        for (int i = idx; i > 0; i -= (i & (-i)))",
			"            ans += bit[i];",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "binary index tree for fast range query execution"
	},
	"disjoint set union": {
		"prefix": "dsu",
		"body": [
			"template<typename T>",
			"class DSU",
			"{",
			"  vector<T> parent;",
			"  vector<T> rank;",
			"",
			"public:",
			"  DSU(int n) : parent(n + 1, -1), rank(n + 1, 1) {}",
			"  T find(T x)",
			"  {",
			"    if (parent[x] < 0)",
			"      return x;",
			"    return parent[x] = find(parent[x]);",
			"  }",
			"  bool join(T x, T y)",
			"  {",
			"    x = find(x);",
			"    y = find(y);",
			"    if (x == y)",
			"      return false;",
			"    if (rank[x] < rank[y])",
			"      swap(x, y);",
			"    rank[x] += rank[y];",
			"    parent[y] = x;",
			"    return true;",
			"  }",
			"  unordered_map<T, vector<T>> allSets()",
			"  {",
			"    unordered_map<T, vector<T>> res;",
			"    for (int i = 1; i < parent.size(); i++)",
			"    {",
			"      T x = find(i);",
			"      res[x].push_back(i);",
			"    }",
			"    return res;",
			"  }",
			"};"
		],
		"description": "disjoint set union"
	}
}